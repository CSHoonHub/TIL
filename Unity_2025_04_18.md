
## c# 관련 내용

### 1. 객체란 무엇인가? 클래스와는 어떤 연관이 있는가?

객체는 변수, 함수, 자료 구조의 조합이자 속성과 기능을 가지는 프로그램 단위이다,

클래스는 객체에 속성과 기능을 넣어주는 설계도이다

그리고 인스턴스는 클래스에 소속된 개별적인 객체이다, 이때 클래스를 바탕으로 실체화되어 메모리에 할당된 것이다

즉 객체는 소프트웨어 세계에서 구현할 대상이고, 설계도에 따라 소프트웨어 세계에 구현된 실체가 인스턴스이다 

### 2. 생성자는 무엇인가?

생성자는 객체 지향 프로그래밍에서 객체가 생성될때, 초기화 시켜주는 함수를 의미한다
생성자는 따로 자료형을 가지지 않는다!

### 3. 접근제한자는 무엇이고 대표적인 제한자의 차이는 무엇인가?

접근 제한자는 외부로부터 타입 (클래스, 구조체, 인터페이스, 델리게이트 등) 혹은 그 타입 멤버들 (메서드, 속성, 이벤트)로의 접근을 제한할 때 사용하는 것으로 다음과 같은 종류가 존재한다

public : 모든 외부에서 이 타입에 접근할 수 있다

internal : 해당 솔루션 프로젝트에서 public 처럼 사용된다, 클래스를 생성할 경우 아무런 접근 제한자를 설정하지 않았다면 기본값이 되는 접근제한자이다.

private : 동일 클래스, 구조체 내의 멤버들만 접근이 가능하다

protected : 상속받은 자식의 클래스에서만 접근하여 사용하는 것이 가능하다

### 4. static 한정자란?

특정 인스턴스에 속하는 변수가 아니라 형식 자체에 속하는 정적필드이다

메모리 영역에 저장되어 프로그램이 종료될 때까지 메모리상에 남아있다 

따라서 몇 개의 인스턴스를 생성하든 클래스 당 하나의 값을 갖는다

static을 사용하는 이유는 인스턴스 간의 값을 공유하기 위해서이다.

### 5. SOLID 원칙은 무엇인가?

`S: Single Responsibility`  단일 책임 원칙

`O: Open-Closed Principle`  개방 패쇄 원칙

`L: Liskov Substitutuion`  리스코프 치환 원칙

`I: Inrterface Segregation`  인터페이스 분리 원칙

`D: Dependency Inversion` 의존 역전 원칙

클래스는 단 한개의 기능만을 가져야 한다, 클래스를 변경하는 이유는 단 하나여야 한다
(유지보수와 연결되는 원칙이다)

확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다
즉, 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 한다
(기존 코드를 수정하지 않고도, 유연하게 짜야한다)

하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 한다
(상위 타입 객체를 하위 타입 객체로 치환해도 정상적으로 작동해야함)

클라이언트는 자신이 사용하는 메소드에만 의존해야한다, 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야한다, 즉 인터페이스는 해당 인터페이스를 사용하는 클라이언트를 기준으로 잘게 분리되어야 한다

의존 관계를 선언할경우, 변하기 쉬운 것보다는 변하기 어려운 것에 의존해야한다
즉, 구체화된 클래스에 의존하기 보다는 추상 클래스 또는 인터페이스에 의존하게끔 해야한다

## 6.객체지향 프로그래밍의 속성 중 하나인 다형성과 이를 활용한 법은 어떤 장점이 있는가?

다형성은 객체지향 프로그래밍에서 "하나의 인터페이스"가 여러 형태를 가질 수 있는 성질을 의미한다, 

대표적인 활용 방법은 다음과 같다

부모 클래스를 타입으로 받아서, 실제로 다양한 자식 클래스 객체를 쓸 수 있음

메서드를 오버라이딩해서, 자식 클래스마다 다르게 동작할 수 있음 

인터페이스를 구현해서 다양한 동작을 통합할 수 있음

추가로 다형성의 장점은 코드 확장성, 코드 재사용성이 증가하고, 프로그램 흐름 중, 원하는 객체를 바꿔끼우기 쉽기 때문에  원하는 함수를 호출하는 것이 가능하다

## 7.override와 overload는 무엇인가???

먼저 개념적인 차이점을 알아보자

오버로드는 메서드의 이름은 같도 매개변수의 유형과 갯수가 다르도록 설정하는 것을 의미한다

오버라이딩은 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의 해서 사용하는 것을 의미한다

즉, 오버로드는 기존에 없던 새로운 메서드를 정의하는 것이고, 오버라이딩은 상속받은 메서드의 내용만 변경하는 것이다 

오버로드를 사용하면 같은 기능을 하는 메서드를 하나의 이름으로 사용할 수 있게 된다

오버라이딩을 사용하면 상위 클래스가 가지고 있는 메서드도 하위 클래스로 상속되어 사용하는 것이 가능하고, 하위 클래스에서 해당 메서드를 재정의 하여 사용하는 것도 가능하다

## 8.확장 메서드는 무엇이고, 어떤 방식으로 활용되는가?

확장 메서드는 기존 클래스의 기능을 확장하는 것이다

클래스의 외부에서 클래스의 메서드 처럼 사용할 수 있는 새로운 메서드를 만들 수 있는 기능이다 

확장 메서드를 사용할 때는 

정적 클래스 (static class)와 
정적 메서드 (static method) 
첫 번째 매개변수 this 키워드가 필요하다

보통 `int`나 `string`등 내가 자주 쓰는 기능을 추가하거나, 유니티에서 `Gameobject`또는  `Transform`등에 추가하여 사용하게 된다

## 9.콜백은 무엇인가?

어떤 일이 끝난 뒤 호출해달라고 미리 넘겨두는 함수

즉 일을 받았을때, 부재중이라면 미리 메모를 남겨놓고 그 메모를 보고 다시 전화를 거는 방식이라고 할 수 있다

보통 코루틴 만큼 기다렸다가 bool값으로 된 값이 invoke 되면 실행할때 사용하였다

보통 어떤 작업이 완료 되었을때, 불러서 사용할 수 있도록 하는 방식이 대표적이다 


## unity 관련 내용

## 1. 유니티 생명주기 함수란 무엇인가???


유니티 함수는 실행 순서가 나누어져 있는데, 공식 문서를 통해 해당방법으로 나눌수 있다

- 첫번째 씬 로드
`Awake` : 항상 start 함수 전에 호출되고, 프리팹이 인스턴스화 된 직후에 호출된다
`OnEnable` : 오브젝트 활성화 이후, 이 함수를 호출한다, 레벨이 로드 되거나, 스크립트 컴포넌트를 포함한 게임 오브젝트가 인스턴스화 될 때 역시 호출된다

- 첫번째 프레임 업데이트 전에
`Start` : 스크립트 인스턴스가 활성화 된 경우에만 첫 번째 프레임 업데이트 전에 호출된다

- 그 프레임의 사이
`OnApplicationPause` : 이 함수는 일시 정지가 감지된 프레임의 끝, 일반적으로 프레임 업데이트 사이에 호출된다

- 업데이트 순서
`FixedUpdate` : 프레임 기반으로 호출되는 것이 아닌 fixed timestep에 설정된 값에 따라
일정한 간격으로 호출된다 물리 효과가 적용된 오브젝트를 조정할 때, 수학적 계산과 연산처리가 필요한 과정일때 주로 호출된다

 `Update` : 스크립트가 활성화 상태일때, 매 프레임마다 호출된다.

 `LateUpdate` : 캐릭터를 움직이고, Update에 딸 움직임을 수행하게 되는 경우 사용된다 
 주로 카메라 움직임에 사용된다

## 2. 코루틴은 무엇인가?

메서드를 호출하게 되면 실행을 오나료한 뒤 호출한 메서드에서 값을 반환한다

하지만 코루틴을 사용하게 되면, 작업을 다수의 프레임에 분산할 수 있다

즉, 실행을 일시정지하고, 제어를 유니티에 반환하지만, 중단한 부분에서 다음 프레임을 계속 진행할 수 있게끔 하는 메서드이다

코드 내에서 실행 도중에, 처리를 대기시키거나 동시에 처리되게끔 보이게 할 수 있다

예를 들어, 실행 도중 특정 오브젝트의 알파값을 점진적으로 감소시키거나 페이드 인 / 아웃 작업이 가능하다 

## 3. Invoke와 코루틴의 차이는 무엇인가?

`Invoke`는 특정 함수를 일정 시간 이후에 실행할 수 있는 기능이다 타이밍을 제어하는 기능은 가능하지만, 코루틴과 같이 반복하거나 병렬로 진행하기엔 세밀하게 작동하지는 않는다

무엇보다도, `Invoke`는 단순히 함수의 이름만 전달할 수 있고, 그 함수의 매개변수 전달은 불가능하다 그럴 때에는 코루틴을 사용해야한다, 즉 단순한 지연 실행에 있어서는 코루틴 보다는 간단하지만 성능면에서는 많이 떨어지는 것이 사실이다  

그리고 실행된 인보크를 중지하기 위해서는 `CancelInvoke`를 사용하거나 오브젝트를 파괴시켜야 한다 

## 4. 코루틴과 멀티쓰래딩은 어떤 차이가 있는가?

`MultiThreading`은 CPU 코어를 여러개 사용하여, 여러 작업을 동시에 하는 것이다 

`코루틴`은 잠시 쉬다가 리턴 될때, 다시 불러서 작업을 하게 된다


## 5. 유니티에서 `Find`함수를 자제해야 하는 이유는 무엇인가?

유니티에서 Find함수는 객체를 이름으로 찾기 위해 사용되지만, 모든 객체를 검색하기 때문에, 

오브젝트(객체)가 많을 경우에 성능 저하를 필히 일으키게 된다, 

또한 객체의 이름이 바뀔때마다, find함수를 사용하는 코드도 바꿔줘야한다, 

그래서 상위 객체를 만들어 참조하게끔 하거나, 매니저를 통해 객체를 참조하게끔 한다

- 모자랄까봐 미리 걱정하는 것이 결핍된 상태이다
- 많이 가진 사람도 결핍하고 항상 급급해한다
- 마음의 여유를 가지고 계획적으로 접근하고
- 유도리있게끔 움직이자
