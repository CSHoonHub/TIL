기본 플레이 사이클

1. 의뢰 수락 씬이 어떻게 되는지 그림이 필요할거 같음

예상되는 사용 개발 구현 기술

- 유니티 내에서 사용되는 button click event를 통해 퀘스트 수락기능 구현
- UI sound effect를 통하여 복잡한 로직 구현없이도 작동이 가능할 거 같음

2. 암살 루트 설계

< 음악에 맞춘 행동 조립형 암살 설계 >

step1.  음악 선택

- scroll bar를 적용하여, 해당되는 음악을 선택함
혹은 키 값을 직접 넣어 q / e 그리고 enter버튼 또는 클릭으로 인한 다음 씬으로 전환으로 기능 구현 가능함
< input system 구현 >

step2. 도구 및 행동 배치
이동, 대기, 덫 설치, 유인, 암살등 기존에 있는 행동블럭을 
- 프리팹화 시켜 리스트에 넣어놓고 불러오는 방법으로 기능구현

루트 타임 라인
루트 타임 라인 (하단 UI)를 통해 행동 블럭을 배치 시 고스트(음악노드)가 씬에 생성됨 
완전한 루트 타임라인이 완성이 되면 고스트(음악노드)가 생성되어 순서대로 (루트타임라인에 먼저 배치된) 미리 확인 가능

- 해당 기능 역시 블럭을 저장해둘 Ui를 미리 생성하여 한 화면에 맞춘뒤, 
- 해당하는 Ui 프리팹을 하단ui에 이벤트 형식 또는함수로 호출하여 
- 각각 프리팹 마다 연결되어 있는 함수를 통해 고스트를 씬에다 보여줌
- 해당 방법을 사용할 시 프리팹의 갯수가 많아짐, Ui프리팹과 고스트 프리팹을 생성하여 함수로 연결시켜줄 작업이 필요함

step3. 암살 수행 <중요핵심기능>
예시) 루트 타임 라인 옆의 플레이 버튼을 통해 누르면, 암살이 시작됨
플레이어가 3인칭 공간에서 고스트로 이동, 타격, 대상 처치 3가지 과정 
( 기존에 생각했던 리듬게임의 다양한 노드 ) <슬라이드, 꾹 누르기, 터치하기>
에 해당되고, 선택한 음악의 BPM (난이도)에 따라 타이밍이 정확할 수록 점수를 획득한다

- 고스트 노트 참조 링크
https://blog.naver.com/sinwoovj/222978952570
-

-더 자세한 구현기술 조문필요;; 

step4, 점수 및 보상

이하 조건에 따른 ui 팝업을 2가지를 만들어 표시함(프리팹)

1. 완료조건
플레이어가 타겟을 최소 조건에 맞게 처치
+ 최소조건: 타겟의 처치, 암살 전 동선에 따른 타겟 의심 수치(?) N%(혹은int n)이하 주변인 의심 수치 n 이하
+ 보너스 조건 : 특정 행동블럭 또는 도구의 사용, 음악사용에 따른 추가 점수

2.실패조건 (아래의 조건 중 하나라도 부합하는 경우 실패)
- 타겟 의심 수치(?) n이상
- 주변인 의심 수치(?) n 이상 
- 선택한 노래의 BPM 내에 완료하지 못하는 경우 

이하 개인적으로 느낀 구체화가 되었으면 좋겠는 기획요소들

1. 타켓 의심 수치는 게임에 어떤 영향을 끼치는지에 대한 질문

2. 2D가 아닌 3D로 3인칭으로 게임이 진행여부에 대한 질문

3. 예상하는 총 게임씬이 몇개 정도 필요한지에 대한 질문


제네릭 싱글톤 클래스 만들어서 뜯어고쳐보고 돌려보기

```c#
// 제네릭 싱글톤 클래스
public class SingleTon<T>: MonoBehaviour where T : MonoBehaviour
{
  // 싱글톤 인스턴스 저장 변수
  static T _instance;
  // 싱글톤 인스턴스를 가져오는 프로퍼티
  public static T instance
  {
     get
     {
          // 인스턴스가 없으면 찾거나 생성
          if(_instance == null)
          { 
            // 현재 씬에서 T타입의 오브젝트를 찾아 할당
            _instance = (T)FindObjectOfType(typeof(T));
            
            // 만약 씬에 존재하지 않으면 새로운 게임 오브젝트를 생성하여 추가
            if(_instance == null)
            {
                string name = typeof(T).ToString(); // 오브젝트 이름을 클래스 이름으로 지정
                var singletonObj = new GameObject(name); // 새 게임 오브젝트 생성
                _instance = singletonObj.AddComponent<T>(); // T 컴포넌트 추가 
                DontDestroyOnLoad(singletonObj); // 씬이 변경되어도 삭제되지 않도록 설정
             }
           }
           return _instance;
       }
}

 private void Awake()
    {
        // 싱글톤 오브젝트를 루트로 설정하여 씬 변경 시 유지되도록 처리
       if(transform.root != null || transform.parenrt != null)
       DonDestroyOnLoad(transform.root); // 부모가 존재하면 루트 오브젝트를 유지
       else if(_instance != null)
       Destroy(this.gameObject); // 기존 인스턴스가 존재하면 중복 생성 방지를 위해 삭제
   }
}
```

싱글톤 패턴 구현 : instance 프로퍼티를 통해 하나의 인스턴스만 생성되도록 보장
자동 생성: 씬에서 해당 타입의 오브젝트가 없을 경우 새 게임 오브젝트를 만들어 컴포넌트를 추가
DontDestroyOnLoad 처리 : 씬이 바뀌어도 싱글톤 오브젝트가 삭제되지 않도록 유지
Awake에서 중복 방지: 중복된 싱글톤이 생성되지 않도록 기존 인스턴스가 존재하면 삭제
