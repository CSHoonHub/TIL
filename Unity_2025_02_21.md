## Class와 Instacne

Class = 문법 + 코드 안에만 존재하는 것  
Instance = 메모리에 할당된 객체 / 클래스 (하드웨어 적으로 Heap에 존재하는 것)   
객체에 필요한 속성, 기능을 Class로 관리한다는 것  

정말 기본적인 내용이지만, 꼭 잡고 가야하는 내용이다! 

## 객체지향의 5원칙
### SOLID

-> 객체지향의 5원칙

`SRP` 단일책임원칙  

`OCP` 개방 - 폐쇄 원칙  

`LSP` 리스코프 치환 법칙

`ISP` 인터페이스 분리 원칙

`DIP` 의존 역전 원칙

- Single Responsibility Principle (단일 책임 원칙)  
하나의 클래스는 하나의 책임만 가져야 한다
클래스를 변경하는 이유는 단 하나여야 한다  
변경이 있을 때, 꼬이지 않도록, 파급 효과가 적어야 한다  

- 즉 하나의 클래스가 수행할 수 있는 기능 (책임) 이 여러개라면, 클래스 내부의 함수끼리 강한 결합을 가질 가능성이
  높아질 경우, 코드의 효율 또한 떨어지게 된다  

  때문에, 하나의 클래스는 하나의 책임을 가지도록 책임을 분리시켜야 한다!!!

- Open-Closed Principle (개방 - 패쇄 원칙)  
소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다  
즉, 기존의 코드를 변경하지 않고 기능을 수정, 추가할 수 있도록 설계해야한다  
인터체이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현하는 것
상속 (다형성), 추상화 (인터페이스)를 활용하면 된다  

- Liskov Substitution Principle (리스코프 치환 원칙)  
하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 한다  
즉, 무리한 오버라이드는 안하는 거 일수록 좋다는 것이다 
리스코프 치환 원칙을 위반하게 되면 자연스럽게 개방-패쇄 원칙도 무시하게 된다!

- Interface Segregation Principle (인터페이스 분리 원칙)  
클라이언트는 자신이 사용하는 메소드에만 의존해야 한다
인터페이스 여러개가 범용 인터페이스 한개 보다 나은 것이다  
인터페이스는 해당 인터페이스를 사용하는 클라이언트를 기준으로 잘게 분리되어야 한다는 점  
사용하지 않는 인터페이스는 영향을 받지 않도록 만드는 것이 중요하다!!! 

- Dependency Inversion Principle (의존 역전 원칙)  
인터페이스에 의존해야지, 클래스에 의존하면 안된다는 점  
변하기 어려운 추상적인 것에 의존해야 한다는 것이다!  

## 객체 지향 특강을 듣고나서 느낀점 및 배운점

유니티라는 엔진을 배우면서, 좀 더 객체지향에 가깝게 사용하는 것이 좋았다고 느꼈고, 

최대한 기능을 분배해서 재사용 하는 것이 좋다는 것을 알았다면

이제 그 객체 지향 (OOP)라는 것이 정확하게 어떤 것인지 아는 것이 중요하다고 생각했는데, 

마침 특강을 들을 수 있는 기회가 생겨서 듣게 되었다

## 특강을 듣고나서, 지금 해당하는 과제를 정리해서 객체적으로 접근해 도식화 해보았다  

