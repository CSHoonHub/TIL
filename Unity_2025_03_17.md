## 코루틴을 이용하여, 단계별 생성되는 나무 만들기!

코루틴을 사용하다보니, 나무가 재생성되는 오브젝트를 시간에 따라서 만들 수 있겠다는 생각이 들었다,

해서 일단은 자원을 리스폰 해주는 스포너를 생성하였다

``` c#
public class ResourceRespawnManager : MonoBehaviour
{
    [System.Serializable]
    public class ResourceSpawnPoint
    {
        public GameObject resourcePrefab;  // 생성할 자원 프리팹
        public Transform spawnPoint;       // 생성 위치
        public float respawnTime = 10f;    // 리스폰 시간
        public bool isRespawning = false;  // 리스폰 진행 여부
    }

    public List<ResourceSpawnPoint> resourceSpawnPoints = new List<ResourceSpawnPoint>();

    private void Start()
    {
        foreach (var resource in resourceSpawnPoints)
        {
            SpawnResource(resource);
        }
    }

    public void ResourceCollected(ResourceSpawnPoint resource)
    {
        if (!resource.isRespawning)
        {
            StartCoroutine(RespawnResource(resource));
        }
    }

    private IEnumerator RespawnResource(ResourceSpawnPoint resource)
    {
        resource.isRespawning = true;
        yield return new WaitForSeconds(resource.respawnTime);

        SpawnResource(resource);
        resource.isRespawning = false;
    }

    private void SpawnResource(ResourceSpawnPoint resource)
    {
        Instantiate(resource.resourcePrefab, resource.spawnPoint.position, resource.spawnPoint.rotation);
    }
}
```

그래서 스포너에서 전부 다, 관리할려고 했으나 OnDisable에서 한꺼번에 관리하면 되지 않을까 싶었다,
그리고 ResourceSpawner에서 스폰이랑, 크기만 조절해주기로 하였다

``` c#
ublic class ResourceSpawner : MonoBehaviour
{
    public float respawnTime = 5f;
    public int OriginCapacity = 5;
    
    public void SpawnStart()
    {
        StartCoroutine(RespawnResource(respawnTime));
    }

    private IEnumerator RespawnResource(float time)
    {
        yield return new WaitForSeconds(time / 3);
        transform.GetChild(0).gameObject.SetActive(true);
        transform.GetChild(0).localScale = new Vector3(0.3f, 0.3f, 0.3f); 
        yield return new WaitForSeconds(time / 3);
        transform.GetChild(0).localScale = new Vector3(0.6f, 0.6f, 0.6f);
        yield return new WaitForSeconds(time / 3);
        transform.GetChild(0).localScale = new Vector3(1.0f, 1.0f, 1.0f);
        GetComponentInChildren<ResourceObject>().capacity = OriginCapacity;
    }
}
```



